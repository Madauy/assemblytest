DATA:
    arr 7
        12
        4
        0
    len 4
    one 1

CODE:
    MOV B, arr      ; B = dirección base del arreglo
    MOV A, len      ; A = longitud del arreglo

MIN_MAX_SORT:
    SUB A, one      ; A -= 1
    JEQ END_SORT
    PUSH A          ; Guardar A en la pila (longitud actualizada)

    MOV A, B        ; A = dirección base del arreglo
    ADD A, len      ; A = dirección final del arreglo
    SUB A, one      ; A -= 1 (último elemento)
    PUSH A          ; Guardar A en la pila (dirección final)

MIN_LOOP:
    PUSH B          ; Guardar B en la pila
    INC B           ; Incrementar la dirección en B
    MOV A, (B)      ; A = elemento en la dirección B
    POP B           ; Recuperar B de la pila
    CMP A, (B)      ; Comparar A con el elemento en la dirección B
    JGT MIN_SWAP    ; Si A > elemento en la dirección B, intercambiar los elementos

NEXT_ELEMENT:
    INC B           ; Incrementar la dirección en B
    POP A           ; Recuperar la dirección final del arreglo de la pila
    CMP A, B        ; Comparar la dirección en B con la dirección final
    JNE MIN_LOOP    ; Si B != dirección final, continuar con el siguiente elemento
    PUSH A          ; Guardar A en la pila (dirección final)

    POP A           ; Recuperar la longitud actualizada de la pila
    JMP MIN_MAX_SORT

MIN_SWAP:
    PUSH B          ; Guardar B en la pila
    INC B           ; Incrementar la dirección en B
    MOV A, (B)      ; A = elemento en la dirección B
    POP B           ; Recuperar B de la pila
    PUSH A          ; Guardar A en la pila (elemento siguiente)
    MOV A, (B)      ; A = elemento en la dirección B
    INC B           ; Incrementar la dirección en B
    MOV (B), A      ; Guardar A (elemento actual) en la siguiente posición
    DEC B           ; Decrementar la dirección en B
    POP A           ; Recuperar A de la pila (elemento siguiente)
    MOV (B), A      ; Guardar A (elemento siguiente) en la posición actual
    JMP NEXT_ELEMENT

END_SORT:

